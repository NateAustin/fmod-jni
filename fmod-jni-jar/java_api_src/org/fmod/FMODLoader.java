package org.fmod;

import com.sun.istack.internal.Nullable;
import com.sun.xml.internal.ws.util.StreamUtils;

import java.io.*;
import java.util.zip.CRC32;

/**
 * Top-level class to handle JNI initialization
 * <p>
 * <p>
 * TODO: The jni code is generated by SWIG and is honestly pretty ugly. A better solution might be to hand-roll the interface, but, I don't have the time/inclination to try it.
 * <p>
 * TODO: the "constants" file is horribly named, located, and formatted. find a better solution. Oh also.. it makes static jni calls SO GROSS.
 * <p>
 * Author: Nate
 * Date: 5/1/2015
 */
public class FMODLoader {

	/**
	 * retrieve the error message
	 */
	public static String error;

	/**
	 * Load the fmod runtime libraries. This must be called before any apis can be used.
	 * <p>
	 * This function assumes the native libs are located in the working directory working directory.
	 * TODO: determine load order for native dependencies so we can load them correctly instead of requiring them on the PATH.
	 * <p>
	 * This function has no other side effects.
	 * Please call only once?
	 *
	 * @return true if the library was loaded, false otherwise.
	 */
	public static boolean loadNatives() {
		//This logic was cribbed from:
		//com.badlogic.gdx.jnigen/JniGenSharedLibraryLoader
		//https://github.com/libgdx/libgdx/blob/26f1c3fbc5a96ffd9e63d31c2b07f8d5dac9c95d/extensions/gdx-jnigen/src/com/badlogic/gdx/jnigen/JniGenSharedLibraryLoader.java
		//Thanks!
		String folder = "/fmod_runtimes/";

		boolean isWindows = java.lang.System.getProperty("os.name").contains("Windows");
		boolean isLinux = java.lang.System.getProperty("os.name").contains("Linux");
		boolean isMac = java.lang.System.getProperty("os.name").contains("Mac");
		boolean isAndroid = false;
		boolean is64Bit = java.lang.System.getProperty("os.arch").equals("amd64") || java.lang.System.getProperty("os.arch").equals("x86_64");
		String vm = java.lang.System.getProperty("java.vm.name");
		if (vm != null && vm.contains("Dalvik")) {
			isAndroid = true;
			isWindows = false;
			isLinux = false;
			isMac = false;
			is64Bit = false;
		}

		//any other stuff here?

		//first, the fmod low level dll
		if (!loadNativeLibraryFromJar(folder, "fmod", isWindows, isLinux, isMac, isAndroid, is64Bit)) return false;
		//then the fmod studio dll
		if (!loadNativeLibraryFromJar(folder, "fmodstudio", isWindows, isLinux, isMac, isAndroid, is64Bit))
			return false;
		//finally, our JNI glue DLL
		return loadNativeLibraryFromJar(folder, "fmodJNI", isWindows, isLinux, isMac, isAndroid, is64Bit);
	}

	private static boolean loadNativeLibraryFromJar(String folderName, String sharedLibName, boolean isWindows, boolean isLinux, boolean isMac, boolean isAndroid, boolean is64Bit) {
		boolean loaded = false;
		if (isWindows) {
			if (!is64Bit)
				loaded = loadLibrary(folderName + sharedLibName + ".dll");
			else
				loaded = loadLibrary(folderName + sharedLibName + "64.dll");
		}
		if (isLinux) {
			loaded = loadLibrary(folderName + "lib" + sharedLibName + ".so");
		}
		if (isMac) {
			loaded = loadLibrary(folderName + "lib" + sharedLibName + ".dylib");
		}
		if (isAndroid) {
			loaded = loadAndroidLibrary(folderName, sharedLibName);
		}
		return loaded;
	}

	private static boolean loadAndroidLibrary(String folderName, String libName) {
		try {
			java.lang.System.loadLibrary(folderName + libName);
			return true;
		} catch (UnsatisfiedLinkError linkError) {
			failWithError(libName, linkError);
		}
		return false;
	}

	private static boolean loadLibrary(String sharedLibName) {
		if (sharedLibName == null) return false;

		String sourceCrc = crc(FMODLoader.class.getResourceAsStream(sharedLibName));

		File file;
		Throwable ex = null;
		
		// Temp directory with username in path.
		String user = System.getProperty("user.name");
		file = new File(System.getProperty("java.io.tmpdir") + "/jnigen/" + user + "/" + sourceCrc, sharedLibName);
		ex = tryLoad(sharedLibName, sourceCrc, file);
		if (ex == null) return true;
		 
		// System provided temp directory.
		try {
			file = File.createTempFile(sourceCrc, null);
			file.delete();
			file.mkdir();
			file = new File(file, sharedLibName);
			ex = tryLoad(sharedLibName, sourceCrc, file);
			if (ex == null){
				return true;
			}
		} catch (Throwable t) {
			ex = t;
		}

		// User home.
		file = new File(System.getProperty("user.home") + "/.libgdx/" + sourceCrc, sharedLibName);
		ex = tryLoad(sharedLibName, sourceCrc, file);
		if (ex == null) {
			return true;
		}

		// Relative directory.
		file = new File(".temp/" + sourceCrc, sharedLibName);
		ex = tryLoad(sharedLibName, sourceCrc, file);
		if (ex == null) {
			return true;
		}

		// Fallback to java.library.path location, eg for applets.
		file = new File(System.getProperty("java.library.path"), sharedLibName);
		if (file.exists()) {
			try {
				System.load(file.getAbsolutePath());
				return true;
			} catch (Throwable t) {
				ex = t;
			}
		}
		
		failWithError(sharedLibName, ex);
		return false;
	}
	
	private static @Nullable Throwable tryLoad(String sharedLibName, String sourceCrc, File file) {
		
		try {
			String path = extractLibrary(sharedLibName, sourceCrc, file);
			if (path == null) {
				return new RuntimeException("failed to extract library to path: " + file.getAbsolutePath());
			}
			System.load(path);
		} catch (Throwable t) {
			//was an error. this is weirdly common, some machines can't load from the first or second choice locations.
			return t;
		}
		//success!
		return null;
	}

	private static void failWithError(String sharedLibName, Throwable t) {
		StringWriter writer = new StringWriter(256);
		t.printStackTrace(new PrintWriter(writer));
		String errMsg = writer.toString().trim();
		error = "failed to load " + sharedLibName + " with " + t.toString() + ": " + errMsg;
		System.out.println(error);
	}

	/**
	 * Returns a CRC of the remaining bytes in the stream.
	 */
	public static String crc(InputStream input) {
		if (input == null) return "" + System.nanoTime(); // fallback
		CRC32 crc = new CRC32();
		byte[] buffer = new byte[4096];
		try {
			while (true) {
				int length = input.read(buffer);
				if (length == -1) break;
				crc.update(buffer, 0, length);
			}
		} catch (Exception ex) {
			try {
				input.close();
			} catch (Exception ignored) {
			}
		}
		return Long.toString(crc.getValue());
	}

	private static String extractLibrary(String sharedLibName, String srcCrc, File nativeFile) {
		String extractedCrc = null;
		if (nativeFile.exists()) {
			try {
				extractedCrc = crc(new FileInputStream(nativeFile));
			} catch (FileNotFoundException ignored) {
			}
		}

		if (extractedCrc == null || !extractedCrc.equals(srcCrc)) {
			
			InputStream input = null;
			FileOutputStream output = null;
			try {
				// Extract native from classpath to temp dir.
				input = FMODLoader.class.getResourceAsStream(sharedLibName);
				if (input == null) return null;
				nativeFile.getParentFile().mkdirs();
				output = new FileOutputStream(nativeFile);
				byte[] buffer = new byte[4096];
				while (true) {
					int length = input.read(buffer);
					if (length == -1) break;
					output.write(buffer, 0, length);
				}
			} catch (IOException ex) {
				throw new RuntimeException(ex);
			} finally {
				closeQuietly(input);
				closeQuietly(output);
			}
		}
		return nativeFile.exists() ? nativeFile.getAbsolutePath() : null;
	}

	/**
	 * Close and ignore all errors.
	 */
	public static void closeQuietly(Closeable c) {
		if (c != null) {
			try {
				c.close();
			} catch (Throwable ignored) {
			}
		}
	}


	//TODO: add global system functions:
	//inline FMOD_RESULT Memory_Initialize    (void *poolmem, int poollen, FMOD_MEMORY_ALLOC_CALLBACK useralloc, FMOD_MEMORY_REALLOC_CALLBACK userrealloc, FMOD_MEMORY_FREE_CALLBACK userfree, FMOD_MEMORY_TYPE memtypeflags = FMOD_MEMORY_ALL) { return FMOD_Memory_Initialize(poolmem, poollen, useralloc, userrealloc, userfree, memtypeflags); }
	//inline FMOD_RESULT Memory_GetStats      (int *currentalloced, int *maxalloced, bool blocking = true) { return FMOD_Memory_GetStats(currentalloced, maxalloced, blocking); }
	//inline FMOD_RESULT Debug_Initialize     (FMOD_DEBUG_FLAGS flags, FMOD_DEBUG_MODE mode = FMOD_DEBUG_MODE_TTY, FMOD_DEBUG_CALLBACK callback = 0, const char *filename = 0) { return FMOD_Debug_Initialize(flags, mode, callback, filename); }
	//inline FMOD_RESULT File_SetDiskBusy     (int busy) { return FMOD_File_SetDiskBusy(busy); }
	//inline FMOD_RESULT File_GetDiskBusy     (int *busy) { return FMOD_File_GetDiskBusy(busy); }

	//...
}
