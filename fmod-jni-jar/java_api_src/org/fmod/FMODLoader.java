package org.fmod;

import com.sun.istack.internal.Nullable;
import com.sun.xml.internal.ws.util.StreamUtils;

import java.io.*;
import java.nio.ByteBuffer;
import java.util.Arrays;
import java.util.zip.CRC32;

/**
 * Top-level class to handle JNI initialization
 * <p>
 * <p>
 * TODO: The jni code is generated by SWIG and is honestly pretty ugly. A better solution might be to hand-roll the interface, but, I don't have the time/inclination to try it.
 * <p>
 * TODO: the "constants" file is horribly named, located, and formatted. find a better solution. Oh also.. it makes static jni calls SO GROSS.
 * <p>
 * Author: Nate
 * Date: 5/1/2015
 */
public class FMODLoader {

	/**
	 * retrieve the error message
	 */
	public static String error;

	/**
	 * Load the fmod runtime libraries. This must be called before any apis can be used.
	 * <p>
	 * This function assumes the native libs are located in the working directory working directory.
	 * TODO: determine load order for native dependencies so we can load them correctly instead of requiring them on the PATH.
	 * <p>
	 * This function has no other side effects.
	 * Please call only once?
	 *
	 * @return true if the library was loaded, false otherwise.
	 */
	public static boolean loadNatives() {
		//This logic was cribbed from:
		//com.badlogic.gdx.jnigen/JniGenSharedLibraryLoader
		//https://github.com/libgdx/libgdx/blob/26f1c3fbc5a96ffd9e63d31c2b07f8d5dac9c95d/extensions/gdx-jnigen/src/com/badlogic/gdx/jnigen/JniGenSharedLibraryLoader.java
		//Thanks!
		String folder = "/fmod_runtimes/";

		boolean isWindows = java.lang.System.getProperty("os.name").contains("Windows");
		boolean isLinux = java.lang.System.getProperty("os.name").contains("Linux");
		boolean isMac = java.lang.System.getProperty("os.name").contains("Mac");
		boolean isAndroid = false;
		boolean is64Bit = java.lang.System.getProperty("os.arch").equals("amd64") || java.lang.System.getProperty("os.arch").equals("x86_64");
		String vm = java.lang.System.getProperty("java.vm.name");
		if (vm != null && vm.contains("Dalvik")) {
			isAndroid = true;
			isWindows = false;
			isLinux = false;
			isMac = false;
			is64Bit = false;
		}

		//any other stuff here?

		//first, the fmod low level dll
		if (!loadNativeLibraryFromJar(folder, "fmod", isWindows, isLinux, isMac, isAndroid, is64Bit)) return false;
		//then the fmod studio dll
		if (!loadNativeLibraryFromJar(folder, "fmodstudio", isWindows, isLinux, isMac, isAndroid, is64Bit))
			return false;
		//finally, our JNI glue DLL
		return loadNativeLibraryFromJar(folder, "fmodJNI", isWindows, isLinux, isMac, isAndroid, is64Bit);
	}

	private static boolean loadNativeLibraryFromJar(String folderName, String sharedLibName, boolean isWindows, boolean isLinux, boolean isMac, boolean isAndroid, boolean is64Bit) {
		boolean loaded = false;
		if (isWindows) {
			if (!is64Bit)
				loaded = loadLibrary(folderName + sharedLibName + ".dll");
			else
				loaded = loadLibrary(folderName + sharedLibName + "64.dll");
		}
		if (isLinux) {
			loaded = loadLibrary(folderName + "lib" + sharedLibName + ".so");
		}
		if (isMac) {
			loaded = loadLibrary(folderName + "lib" + sharedLibName + ".dylib");
		}
		if (isAndroid) {
			loaded = loadAndroidLibrary(folderName, sharedLibName);
		}
		return loaded;
	}

	private static boolean loadAndroidLibrary(String folderName, String libName) {
		try {
			java.lang.System.loadLibrary(folderName + libName);
			return true;
		} catch (UnsatisfiedLinkError linkError) {
			failWithError(libName, linkError);
		}
		return false;
	}

	private static boolean loadLibrary(String sharedLibName) {
		if (sharedLibName == null) return false;

		File file;
		Throwable ex = null;
		ByteBuffer libBytes;
		String sourceCrc = crc(getLibBytes(FMODLoader.class.getResourceAsStream(sharedLibName)));
		
		// Temp directory with username in path.
		String user = System.getProperty("user.name");
		file = new File(System.getProperty("java.io.tmpdir") + "/jnigen/" + user + "/" + sourceCrc, sharedLibName);
		ex = tryLoad(sharedLibName, sourceCrc, file);
		if (ex == null) return true;
		 
		// System provided temp directory.
		try {
			file = File.createTempFile(sourceCrc, null);
			file.delete();
			file.mkdir();
			file = new File(file, sharedLibName);
			ex = tryLoad(sharedLibName, sourceCrc, file);
			if (ex == null){
				return true;
			}
		} catch (Throwable t) {
			ex = t;
		}

		// User home.
		file = new File(System.getProperty("user.home") + "/.libgdx/" + sourceCrc, sharedLibName);
		ex = tryLoad(sharedLibName, sourceCrc, file);
		if (ex == null) {
			return true;
		}

		// Relative directory.
		file = new File(".temp/" + sourceCrc, sharedLibName);
		ex = tryLoad(sharedLibName, sourceCrc, file);
		if (ex == null) {
			return true;
		}

		// Fallback to java.library.path location, eg for applets.
		file = new File(System.getProperty("java.library.path"), sharedLibName);
		if (file.exists()) {
			try {
				System.load(file.getAbsolutePath());
				return true;
			} catch (Throwable t) {
				ex = t;
			}
		}
		
		failWithError(sharedLibName, ex);
		return false;
	}
	
	private static @Nullable Throwable tryLoad(String sharedLibName, String sourceCrc, File file) {
		
		try {
			String path = extractLibrary(sharedLibName, sourceCrc, file);
			if (path == null) {
				return new RuntimeException("failed to extract library to path: " + file.getAbsolutePath());
			}
			System.load(path);
		} catch (Throwable t) {
			//was an error. this is weirdly common, some machines can't load from the first or second choice locations.
			return t;
		}
		//success!
		return null;
	}

	private static void failWithError(String sharedLibName, Throwable t) {
		StringWriter writer = new StringWriter(256);
		t.printStackTrace(new PrintWriter(writer));
		String errMsg = writer.toString().trim();
		error = "failed to load " + sharedLibName + " with " + t.toString() + ": " + errMsg;
		System.out.println(error);
	}

	/**
	 * Returns a CRC of the remaining bytes in the buffer.
	 *
	 * The input buffer will remain unchanged.
	 */
	public static String crc(ByteBuffer input) {
		if (input == null) return "" + System.nanoTime(); // fallback
		CRC32 crc = new CRC32();

		ByteBuffer buf = input.slice(); //so we don't modify the underlying buffer
		byte[] temp = new byte[4096];
		while (buf.hasRemaining()) {
			int length = Math.min(buf.remaining(), temp.length);
			buf.get(temp, 0, length);
			crc.update(temp, 0, length);
		}

		return Long.toString(crc.getValue());
	}

	private static ByteBuffer getLibBytes(InputStream stream) {
		if (stream == null) throw new NullPointerException("Resource stream is null");
		final int bufferSize = 4096; //4kb buffer
		byte[] buffer = new byte[bufferSize];
		ByteArrayOutputStream out = new ByteArrayOutputStream();

		int bytesRead;
		try {
			while ((bytesRead = stream.read(buffer)) != -1) {
				out.write(buffer, 0, bytesRead);
			}
		}
		catch(IOException e) {
			throw new RuntimeException(e);
		}

		return ByteBuffer.wrap(out.toByteArray());
	}

	private static String extractLibrary(String sharedLibName, String srcCrc, File nativeFile) {
		String extractedCrc = null;
		ByteBuffer libBytes = null;
		if(nativeFile.exists()) {
			try {
				libBytes = getLibBytes(new FileInputStream(nativeFile));
				if(ElfExecStackStripper.isELFFile(libBytes)) {
					ElfExecStackStripper.stripExecStackFlag(libBytes);
				}
				extractedCrc = crc(libBytes);
			} catch (FileNotFoundException ignored) {

			}
		}

		if (extractedCrc == null || !extractedCrc.equals(srcCrc)) {

			FileOutputStream output = null;
			try {
				// Extract native from buffer to temp dir
				if (libBytes == null) return null;
				nativeFile.getParentFile().mkdirs();
				output = new FileOutputStream(nativeFile);
				output.write(libBytes.array());
			} catch (IOException ex) {
				throw new RuntimeException(ex);
			} finally {
				closeQuietly(output);
			}
		}
		return nativeFile.exists() ? nativeFile.getAbsolutePath() : null;
	}

	/**
	 * Close and ignore all errors.
	 */
	public static void closeQuietly(Closeable c) {
		if (c != null) {
			try {
				c.close();
			} catch (Throwable ignored) {
			}
		}
	}


	//TODO: add global system functions:
	//inline FMOD_RESULT Memory_Initialize    (void *poolmem, int poollen, FMOD_MEMORY_ALLOC_CALLBACK useralloc, FMOD_MEMORY_REALLOC_CALLBACK userrealloc, FMOD_MEMORY_FREE_CALLBACK userfree, FMOD_MEMORY_TYPE memtypeflags = FMOD_MEMORY_ALL) { return FMOD_Memory_Initialize(poolmem, poollen, useralloc, userrealloc, userfree, memtypeflags); }
	//inline FMOD_RESULT Memory_GetStats      (int *currentalloced, int *maxalloced, bool blocking = true) { return FMOD_Memory_GetStats(currentalloced, maxalloced, blocking); }
	//inline FMOD_RESULT Debug_Initialize     (FMOD_DEBUG_FLAGS flags, FMOD_DEBUG_MODE mode = FMOD_DEBUG_MODE_TTY, FMOD_DEBUG_CALLBACK callback = 0, const char *filename = 0) { return FMOD_Debug_Initialize(flags, mode, callback, filename); }
	//inline FMOD_RESULT File_SetDiskBusy     (int busy) { return FMOD_File_SetDiskBusy(busy); }
	//inline FMOD_RESULT File_GetDiskBusy     (int *busy) { return FMOD_File_GetDiskBusy(busy); }

	//...
}
